# **性能测试故障注入方案**

## **1. 方案概述**

### 1.1 背景与目标

在性能测试中，**故障注入（Fault Injection）**是通过主动模拟系统组件异常（如网络延迟、服务宕机、资源耗尽等），验证系统在故障场景下的 **容错能力、降级策略有效性及恢复能力** 的关键手段。本方案旨在通过可控的故障注入，暴露系统潜在的脆弱性，为高可用架构优化提供数据支撑。

**核心目标**：

* **•**验证系统在部分组件故障时（如数据库宕机、缓存失效、第三方服务超时）是否仍能提供核心功能（如降级返回默认数据、限流保护后端）。
* **•**评估故障对性能指标的影响（如响应时间恶化程度、吞吐量下降比例、错误率上升阈值）。
* **•**明确系统恢复能力（如故障移除后，服务能否自动恢复正常状态）。

### 1.2 适用场景

* **•核心业务链路**：如电商的下单流程（依赖订单服务、库存服务、支付服务）、金融的交易转账（依赖账户服务、风控服务）。
* **•高可用架构组件**：如数据库主从切换、Redis集群节点故障、负载均衡器异常。
* **•第三方依赖**：如外部API（短信服务、地图服务）超时或不可用。

## **2. 故障注入类型与实施方法**

### 2.1 常见故障类型及对应注入手段

| **故障类型**     | **具体场景示例**                                                                                                                             | **注入方法**                                                                                                                          | **工具/技术**                                                                                                            |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **网络类故障**   | - 服务间调用延迟增加（如订单服务→库存服务网络延迟500ms）``- 网络丢包（如数据库连接断续中断）``- DNS解析失败                         | - 使用工具模拟延迟/丢包``- 修改服务部署的网络策略（如iptables丢弃特定端口包）                                                        | **TC (Traffic Control)**（Linux内核流量控制）、**Iptables**（网络包过滤）、**Toxiproxy**（专业故障注入代理） |
| **服务类故障**   | - 下游服务宕机（如库存服务进程崩溃）``- 服务响应超时（如支付服务处理超过5秒未返回）``- 服务返回错误码（如商品服务强制返回500）       | - 手动停止服务进程``- 使用Mock工具拦截请求并返回自定义响应（如500/503）``- 通过代码注入延迟（如Sleep(5000)）                  | **Chaos Mesh**（K8s环境故障注入）、**Gremlin**（云原生故障平台）、**Postman Mock Server**（模拟错误响应）    |
| **资源类故障**   | - CPU资源耗尽（如压测时恶意占用所有CPU核心）``- 内存泄漏（如Java服务堆内存持续增长直至OOM）``- 磁盘I/O阻塞（如数据库日志写入磁盘满） | - 使用压力工具占用CPU（如 `stress-ng`）``- 注入内存泄漏代码（如无限循环分配对象）``- 挂载只读磁盘或填满磁盘空间             | **Stress-ng**（系统资源压测）、**JMeter Beanshell**（脚本注入内存操作）、**dd命令**（磁盘写满）              |
| **中间件故障**   | - Redis缓存宕机（如Redis节点进程停止）``- MySQL主库故障（如主库 crash 后未自动切换）``- 消息队列积压（如Kafka Broker宕机）           | - 手动停止中间件进程（如 `systemctl stop redis`）``- 模拟主从切换失败（如关闭从库同步）``- 停止Kafka Broker并观察生产者阻塞 | **Redis CLI**（关闭服务）、**MySQL Shell**（模拟故障）、**Kafka Manager**（管理Broker状态）                  |
| **依赖服务故障** | - 第三方短信服务超时（如调用短信API超过3秒无响应）``- 地图服务返回502                                                                       | - 使用Mock代理拦截第三方请求并延迟响应（如Toxiproxy设置延迟）``- 修改本地Hosts文件指向无效IP                                         | **Toxiproxy**、**Nginx**（配置反向代理延迟）、**Mockoon**（本地Mock服务）                                    |

### 2.2 实施步骤（以电商系统为例）

#### **步骤1：明确故障注入目标与场景**

* **•目标**：验证“订单创建”链路在缓存失效、库存服务超时时的降级能力。
* **•场景**：* **•**场景1：Redis缓存宕机 → 验证商品查询是否降级直接查MySQL（允许响应时间变长，但需保证成功）。
  * **•**场景2：库存服务响应超时（3秒）→ 验证订单服务是否触发超时熔断（如快速返回“库存校验中，请稍后”提示）。
  * **•**场景3：数据库主库宕机 → 验证系统是否自动切换至从库（或返回“系统繁忙”提示）。

#### **步骤2：选择注入工具并配置故障**

* **•场景1（Redis宕机）**：

  * **•**工具：手动执行 `systemctl stop redis-server`（停止Redis服务） 或 使用Toxiproxy配置Redis代理，设置 `toxic type: latency, delay: 10000ms`（模拟10秒延迟，接近宕机效果）。
  * **•**验证点：订单服务是否切换至直接查询MySQL商品表（检查SQL日志），响应时间是否在可接受范围（如≤2秒）。
* **•场景2（库存服务超时）**：

  * **•**工具：使用Chaos Mesh在库存服务的HTTP接口（`/api/inventory/check`）上注入 `delay: 3000ms`（延迟3秒），或直接修改库存服务代码，在关键逻辑处添加 `Thread.sleep(3000)`。
  * **•**验证点：订单服务是否配置了超时熔断（如Hystrix/Sentinel设置超时时间2秒），超时后是否返回友好提示（如HTTP 504或业务码“INVENTORY_TIMEOUT”）。
* **•场景3（数据库主库宕机）**：

  * **•**工具：手动执行 `systemctl stop mysql-master`（停止主库），或通过ProxySQL配置主从切换策略，模拟主库不可用。
  * **•**验证点：应用是否配置了数据库故障转移（如读写分离中间件自动切换至从库），或是否触发降级逻辑（如返回“订单提交失败，请重试”）。

#### **步骤3：执行故障注入与监控**

* **•压测工具**：在故障注入的同时，使用JMeter/Locust持续发送业务请求（如模拟用户登录→查询商品→创建订单），保持固定并发数（如100用户）。
* **•监控指标**：* **•**业务指标：响应时间（RT）、吞吐量（TPS）、成功率（成功请求占比）、错误类型（如HTTP 500/503、业务码“INVENTORY_UNAVAILABLE”）。
  * **•**系统指标：CPU/内存/磁盘I/O（应用服务器与数据库）、数据库连接池使用率、Redis缓存命中率（若未宕机）。
  * **•**日志：收集服务日志（如订单服务的ERROR日志）、中间件日志（如MySQL慢查询日志、Redis报错日志）。

#### **步骤4：结果分析与恢复验证**

* **•数据分析**：对比故障注入前后的性能指标（如正常情况下订单创建TPS为50，Redis宕机后降至20，RT从1s增至3s）。
* **•容错验证**：检查系统是否触发预期降级策略（如缓存失效后是否返回兜底数据“商品库存未知”），熔断机制是否生效（如库存服务超时后订单服务不再重试）。
* **•恢复验证**：移除故障（如重启Redis/数据库），观察系统是否在设定时间内自动恢复（如30秒内订单服务重新连接Redis，TPS回升至正常水平）。

## **3. 典型故障注入案例（电商系统）**

### **案例1：Redis缓存宕机对商品查询的影响**

* **•注入方法**：通过Toxiproxy代理Redis连接，在压测期间注入 `latency: 10000ms`（10秒延迟）并最终断开连接（模拟宕机）。
* **•预期结果**：* **•**订单服务应检测到Redis不可用，自动切换至直接查询MySQL商品表（检查SQL日志是否有 `SELECT * FROM products WHERE id=?`）。
  * **•**响应时间允许增加（如从平均200ms增至1s），但成功率需≥95%（允许少量超时）。
* **•实际结果**：Redis宕机后，商品查询RT从200ms增至800ms（因直接查MySQL），成功率98%，符合预期；但若未配置降级逻辑，则返回500错误（需优化）。

### **案例2：库存服务超时熔断验证**

* **•注入方法**：使用Chaos Mesh对库存服务的 `/check` **接口注入** `delay: 3000ms`（超过订单服务配置的超时时间2秒）。
* **•预期结果**：订单服务应触发熔断（如Sentinel配置的“慢调用比例阈值≥50%”），快速返回业务码“INVENTORY_TIMEOUT”（而非阻塞等待）。
* **•实际结果**：注入后，订单服务成功拦截超时请求（返回HTTP 200 + 业务码“INVENTORY_TIMEOUT”），TPS从50降至30（因部分请求被降级），错误率10%（可接受），验证了熔断有效性。

## **4. 工具与资源清单**

| **类别** | **工具/技术**            | **用途**                                         |
| -------------- | ------------------------------ | ------------------------------------------------------ |
| 网络故障注入   | TC (Traffic Control)、Iptables | 模拟网络延迟、丢包、DNS故障                            |
| 服务故障注入   | Chaos Mesh、Gremlin            | K8s环境下注入Pod宕机、服务延迟、CPU/内存耗尽           |
| 中间件故障注入 | Toxiproxy、Redis CLI           | 模拟Redis/MySQL/Kafka延迟、宕机                        |
| 资源故障注入   | Stress-ng、dd、JMeter脚本      | 占用CPU/内存/磁盘，模拟资源耗尽                        |
| 监控与日志     | Prometheus+Grafana、ELK        | 实时监控系统指标（CPU/RT/TPS）、收集服务日志与错误信息 |
| 压测工具       | JMeter、Locust                 | 持续发送业务请求，模拟用户负载                         |

## **5. 注意事项**

1. **1.安全边界**：故障注入需在 **隔离环境**（如测试环境/预发布环境）执行，避免影响生产系统；涉及数据操作的故障（如数据库主库宕机）需提前备份数据。
2. **2.渐进式注入**：从单一组件故障开始（如仅Redis延迟），逐步叠加复杂故障（如Redis宕机+库存服务超时），避免同时注入过多故障导致问题难以定位。
3. **3.自动化与回滚**：通过脚本自动化故障注入与恢复（如Ansible/Terraform），并确保故障移除后系统能自动回滚至正常状态（如重启服务、恢复网络配置）。
4. **4.结果关联**：故障注入结果需与基准性能测试数据对比（如正常TPS为100，故障后降至60），明确系统容错能力的量化指标（如“允许核心功能在30%性能下降下仍可用”）。

**附：故障注入检查表**

* **•**[ ] **已明确注入的故障类型、目标组件及业务场景；**
* **•**[ ] **已配置监控工具（实时观察CPU/RT/错误率）；**
* **•**[ ] **已验证降级策略的存在性（如熔断规则、兜底逻辑）；**
* **•**[ ] **已制定故障恢复步骤（如重启服务、重连中间件）；**
* **•**[ ] **已记录基线数据（故障前的正常性能指标）。**

通过系统化的故障注入方案，团队可以主动暴露系统脆弱性，针对性优化高可用设计（如完善熔断降级、增强缓存冗余），最终提升系统在生产环境中的稳定性与可靠性。
